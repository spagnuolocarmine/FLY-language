/*
 * generated by Xtext 2.13.0
 */
package org.xtext.validation

import com.google.inject.Inject
import org.xtext.fLY.BinaryOperation
import org.xtext.typing.FlyTypeProvider
import org.eclipse.emf.ecore.EReference
import org.xtext.fLY.ArithmeticExpression
import org.xtext.typing.FlyType
import org.xtext.fLY.FLYPackage
import org.eclipse.xtext.validation.Check
import org.xtext.fLY.PostfixOperation
import org.xtext.fLY.UnaryOperation
import org.eclipse.emf.ecore.EObject
import org.xtext.fLY.FunctionDefinition
import org.xtext.fLY.Fly
import org.xtext.fLY.FunctionReturn

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class FLYValidator extends AbstractFLYValidator {
	
@Inject extension FlyTypeProvider
	
	public static val FORWARD_REFERENCE = "org.text.fly.ForwardReference";

	public static val WRONG_TYPE = "org.text.fly.WrongType";

	public static val WRONG_ATTR = "org.text.fly.WrongAttribute"

	public static val WRONG_VAL = "org.text.fly.WrongValue"

	public static val DUPLCIATE_VAL = "org.text.fly.DuplicateValue"
	
	public static val WRONG_RETURN = "org.text.fly.WrongReturn"

	def checkType(BinaryOperation e) {
		if (e.feature.equals("+")) {
			val left = getTypeAndCheckNotNull(e.left, FLYPackage.Literals::BINARY_OPERATION__LEFT)
			val right = getTypeAndCheckNotNull(e.right, FLYPackage.Literals::BINARY_OPERATION__RIGHT)
			if (left == FlyTypeProvider::intType || right == FlyTypeProvider::intType ||
				(left != FlyTypeProvider::stringType && right != FlyTypeProvider::stringType
				)) {
				checkNotBoolean(left, FLYPackage.Literals::BINARY_OPERATION__LEFT)
				checkNotBoolean(right, FLYPackage.Literals::BINARY_OPERATION__RIGHT)
			}
		} else if (e.feature.equals("-") || e.feature.equals("*") || e.feature.equals("/")) {
			val left = getTypeAndCheckNotNull(e.left, FLYPackage.Literals::BINARY_OPERATION__LEFT)
			val right = getTypeAndCheckNotNull(e.right, FLYPackage.Literals::BINARY_OPERATION__RIGHT)
			if (left == FlyTypeProvider::intType || right == FlyTypeProvider::intType ||
				(left != FlyTypeProvider::floatType && right != FlyTypeProvider::floatType
				)) {
				checkNotBoolean(left, FLYPackage.Literals::BINARY_OPERATION__LEFT)
				checkNotBoolean(right, FLYPackage.Literals::BINARY_OPERATION__RIGHT)
				checkNotString(left, FLYPackage.Literals::BINARY_OPERATION__LEFT)
				checkNotString(right, FLYPackage.Literals::BINARY_OPERATION__RIGHT)
			}
		} else if (e.feature.equals("and") || e.feature.equals("or")) {
			checkExpectedBoolean(e.left, FLYPackage.Literals::BINARY_OPERATION__LEFT)
			checkExpectedBoolean(e.right, FLYPackage.Literals::BINARY_OPERATION__RIGHT)
		} else if (e.feature.equals("==") || e.feature.equals("!=")) {
			getTypeAndCheckNotNull(e.left, FLYPackage.Literals::BINARY_OPERATION__LEFT)
			getTypeAndCheckNotNull(e.right, FLYPackage.Literals::BINARY_OPERATION__RIGHT)
		} else if (e.feature.equals(">=") || e.feature.equals("<=") || e.feature.equals("<") || e.feature.equals(">")) {
			val left = getTypeAndCheckNotNull(e.left, FLYPackage.Literals::BINARY_OPERATION__LEFT)
			val right = getTypeAndCheckNotNull(e.right, FLYPackage.Literals::BINARY_OPERATION__RIGHT)
			checkNotBoolean(left, FLYPackage.Literals::BINARY_OPERATION__LEFT)
			checkNotBoolean(right, FLYPackage.Literals::BINARY_OPERATION__RIGHT)
		}
	}
	
	
	@Check
	def checkReturn(FunctionReturn ret){
		var parent=getParent(ret);
		if(!(parent instanceof FunctionDefinition)){
			error("the return must be in a function",FLYPackage.Literals::FUNCTION_RETURN__EXPRESSION,WRONG_RETURN)
		}
	}
	
	def private getParent(EObject e){
		if (e instanceof FunctionDefinition || e instanceof Fly){
			return e
		}
		else return getParent(e.eContainer)
	}

	@Check
	def checkType(UnaryOperation e) {
		if (e.feature.equals("!")) {
			checkExpectedBoolean(e.operand, FLYPackage.Literals::UNARY_OPERATION__OPERAND)
		} else {
			checkNotBoolean(e.operand?.typeFor, FLYPackage.Literals::POSTFIX_OPERATION__OPERAND)
			checkNotString(e.operand?.typeFor, FLYPackage.Literals::POSTFIX_OPERATION__OPERAND)
			checkNotObject(e.operand?.typeFor, FLYPackage.Literals::POSTFIX_OPERATION__OPERAND)
			checkNotDat(e.operand?.typeFor, FLYPackage.Literals::POSTFIX_OPERATION__OPERAND)
		}
	}

	@Check
	def checkType(PostfixOperation e) {
		checkNotBoolean(e.operand?.typeFor, FLYPackage.Literals::POSTFIX_OPERATION__OPERAND)
		checkNotString(e.operand?.typeFor, FLYPackage.Literals::POSTFIX_OPERATION__OPERAND)
		checkNotObject(e.operand?.typeFor, FLYPackage.Literals::POSTFIX_OPERATION__OPERAND)
		checkNotDat(e.operand?.typeFor, FLYPackage.Literals::POSTFIX_OPERATION__OPERAND)
	}
	
	def private checkExpectedSame(Object left, Object right) {
		if (right != null && left != null && right != left) {
			error("expected the same type, but was " + left + ", " + right,
				FLYPackage.Literals::BINARY_OPERATION__FEATURE, WRONG_TYPE)
		}
	}

	def private checkNotBoolean(Object type, EReference reference) {
		if (type == FlyTypeProvider::boolType) {
			error("cannot be Boolean", reference, WRONG_TYPE)
		}
	}

	def private checkNotString(Object type, EReference reference) {
		if (type == FlyTypeProvider::stringType) {
			error("cannot be String", reference, WRONG_TYPE)
		}
	}
	

	def private checkNotObject(Object type, EReference reference) {
		if (type == FlyTypeProvider::objectType) {
			error("cannot be Object", reference, WRONG_TYPE)
		}
	}

	def private checkNotDat(Object type, EReference reference) {
		if (type == FlyTypeProvider::datType) {
			error("cannot be Dat variable", reference, WRONG_TYPE)
		}
	}

	def private checkExpectedType(ArithmeticExpression exp, FlyType expectedType, EReference reference) {
		val actualType = getTypeAndCheckNotNull(exp, reference)
		if (actualType != expectedType)
			error("expected " + expectedType + " type, but was " + actualType, reference, WRONG_TYPE)
	}

	def private checkExpectedBoolean(ArithmeticExpression exp, EReference reference) {
		checkExpectedType(exp, FlyTypeProvider::boolType, reference)
	}

	def private checkExpectedInt(ArithmeticExpression exp, EReference reference) {
		checkExpectedType(exp, FlyTypeProvider::intType, reference)
	}

	def private Object getTypeAndCheckNotNull(ArithmeticExpression exp, EReference reference) {
		val type = exp?.typeFor
		if (type == null)
			error("null type", reference, WRONG_TYPE)
		return type
	}
	
}